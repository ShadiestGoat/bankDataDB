package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
)

//go:embed errors.txt
var Errors string

const PREFIX = `
// Code generated by ./external/errors/generator DO NOT EDIT.

package errors
`

type ErrResponse struct {
	Error string `json:"error"`
}

func main() {
	if len(os.Args) != 2 {
		panic("Need a file to write to")
	}

	content := &strings.Builder{}
	content.WriteString(strings.TrimSpace(PREFIX) + "\n\n")

	for l := range strings.SplitSeq(Errors, "\n") {
		if l == "" || strings.HasPrefix(l, "// ") {
			continue
		}

		spl := strings.SplitN(l, ": ", 2)
		if len(spl) != 2 {
			panic("Can't parse errors.txt! Non-2 split")
		}
		spl2 := strings.SplitN(spl[1], " ", 2)
		if len(spl2) != 2 {
			panic("Can't parse errors.txt! Non-2 split")
		}

		s, err := strconv.Atoi(spl2[0])
		if err != nil {
			panic("Can't parse status: " + spl2[0] + " - " + err.Error())
		}
		if strings.Contains(spl2[1], "`") {
			panic("Error can't contain `")
		}

		fmt.Fprintf(content, "var %s = &HTTPError{%d, []byte(`", spl[0], s)

		// You gotta laugh - why the FUCK does json put a new line at the end of an encoded thing???
		buf := &bytes.Buffer{}
		enc := json.NewEncoder(buf)
		enc.SetEscapeHTML(false)
		if err := enc.Encode(ErrResponse{spl2[1]}); err != nil {
			panic("Can't encode json for " + spl2[1] + ": " + err.Error())
		}

		encoded := buf.Bytes()
		content.Write(encoded[:len(encoded) - 1])

		content.WriteString("`)}\n")
	}

	err := os.WriteFile(os.Args[1], []byte(content.String()), 0755)
	if err != nil {
		panic("Can't write final product: " + err.Error())
	}

	fmt.Println("Written!")
}
