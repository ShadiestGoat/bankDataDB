// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock_store

import (
	"context"
	"regexp"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/shadiestgoat/bankDataDB/data"
	"github.com/shadiestgoat/bankDataDB/db/store"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// CreateCategory provides a mock function for the type MockStore
func (_mock *MockStore) CreateCategory(ctx context.Context, authorID string, name string, icon string, color string) (string, error) {
	ret := _mock.Called(ctx, authorID, name, icon, color)

	if len(ret) == 0 {
		panic("no return value specified for CreateCategory")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (string, error)); ok {
		return returnFunc(ctx, authorID, name, icon, color)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) string); ok {
		r0 = returnFunc(ctx, authorID, name, icon, color)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, name, icon, color)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CreateCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCategory'
type MockStore_CreateCategory_Call struct {
	*mock.Call
}

// CreateCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - name string
//   - icon string
//   - color string
func (_e *MockStore_Expecter) CreateCategory(ctx interface{}, authorID interface{}, name interface{}, icon interface{}, color interface{}) *MockStore_CreateCategory_Call {
	return &MockStore_CreateCategory_Call{Call: _e.mock.On("CreateCategory", ctx, authorID, name, icon, color)}
}

func (_c *MockStore_CreateCategory_Call) Run(run func(ctx context.Context, authorID string, name string, icon string, color string)) *MockStore_CreateCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_CreateCategory_Call) Return(s string, err error) *MockStore_CreateCategory_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockStore_CreateCategory_Call) RunAndReturn(run func(ctx context.Context, authorID string, name string, icon string, color string) (string, error)) *MockStore_CreateCategory_Call {
	_c.Call.Return(run)
	return _c
}

// DoesCategoryExist provides a mock function for the type MockStore
func (_mock *MockStore) DoesCategoryExist(ctx context.Context, authorID string, iD string) (bool, error) {
	ret := _mock.Called(ctx, authorID, iD)

	if len(ret) == 0 {
		panic("no return value specified for DoesCategoryExist")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, authorID, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, authorID, iD)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DoesCategoryExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesCategoryExist'
type MockStore_DoesCategoryExist_Call struct {
	*mock.Call
}

// DoesCategoryExist is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - iD string
func (_e *MockStore_Expecter) DoesCategoryExist(ctx interface{}, authorID interface{}, iD interface{}) *MockStore_DoesCategoryExist_Call {
	return &MockStore_DoesCategoryExist_Call{Call: _e.mock.On("DoesCategoryExist", ctx, authorID, iD)}
}

func (_c *MockStore_DoesCategoryExist_Call) Run(run func(ctx context.Context, authorID string, iD string)) *MockStore_DoesCategoryExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_DoesCategoryExist_Call) Return(b bool, err error) *MockStore_DoesCategoryExist_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_DoesCategoryExist_Call) RunAndReturn(run func(ctx context.Context, authorID string, iD string) (bool, error)) *MockStore_DoesCategoryExist_Call {
	_c.Call.Return(run)
	return _c
}

// DoesTransactionExist provides a mock function for the type MockStore
func (_mock *MockStore) DoesTransactionExist(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64) (bool, error) {
	ret := _mock.Called(ctx, authorID, authedAt, settledAt, description, amount)

	if len(ret) == 0 {
		panic("no return value specified for DoesTransactionExist")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time, string, float64) (bool, error)); ok {
		return returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time, string, float64) bool); ok {
		r0 = returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, time.Time, time.Time, string, float64) error); ok {
		r1 = returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DoesTransactionExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesTransactionExist'
type MockStore_DoesTransactionExist_Call struct {
	*mock.Call
}

// DoesTransactionExist is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - authedAt time.Time
//   - settledAt time.Time
//   - description string
//   - amount float64
func (_e *MockStore_Expecter) DoesTransactionExist(ctx interface{}, authorID interface{}, authedAt interface{}, settledAt interface{}, description interface{}, amount interface{}) *MockStore_DoesTransactionExist_Call {
	return &MockStore_DoesTransactionExist_Call{Call: _e.mock.On("DoesTransactionExist", ctx, authorID, authedAt, settledAt, description, amount)}
}

func (_c *MockStore_DoesTransactionExist_Call) Run(run func(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64)) *MockStore_DoesTransactionExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 float64
		if args[5] != nil {
			arg5 = args[5].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockStore_DoesTransactionExist_Call) Return(b bool, err error) *MockStore_DoesTransactionExist_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_DoesTransactionExist_Call) RunAndReturn(run func(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64) (bool, error)) *MockStore_DoesTransactionExist_Call {
	_c.Call.Return(run)
	return _c
}

// ExtDelCategory provides a mock function for the type MockStore
func (_mock *MockStore) ExtDelCategory(ctx context.Context, authorID string, iD string) (int64, error) {
	ret := _mock.Called(ctx, authorID, iD)

	if len(ret) == 0 {
		panic("no return value specified for ExtDelCategory")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (int64, error)); ok {
		return returnFunc(ctx, authorID, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) int64); ok {
		r0 = returnFunc(ctx, authorID, iD)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ExtDelCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtDelCategory'
type MockStore_ExtDelCategory_Call struct {
	*mock.Call
}

// ExtDelCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - iD string
func (_e *MockStore_Expecter) ExtDelCategory(ctx interface{}, authorID interface{}, iD interface{}) *MockStore_ExtDelCategory_Call {
	return &MockStore_ExtDelCategory_Call{Call: _e.mock.On("ExtDelCategory", ctx, authorID, iD)}
}

func (_c *MockStore_ExtDelCategory_Call) Run(run func(ctx context.Context, authorID string, iD string)) *MockStore_ExtDelCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_ExtDelCategory_Call) Return(n int64, err error) *MockStore_ExtDelCategory_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_ExtDelCategory_Call) RunAndReturn(run func(ctx context.Context, authorID string, iD string) (int64, error)) *MockStore_ExtDelCategory_Call {
	_c.Call.Return(run)
	return _c
}

// ExtGetCategories provides a mock function for the type MockStore
func (_mock *MockStore) ExtGetCategories(ctx context.Context, authorID string) ([]*store.ExtGetCategoriesRow, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for ExtGetCategories")
	}

	var r0 []*store.ExtGetCategoriesRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*store.ExtGetCategoriesRow, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*store.ExtGetCategoriesRow); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*store.ExtGetCategoriesRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ExtGetCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtGetCategories'
type MockStore_ExtGetCategories_Call struct {
	*mock.Call
}

// ExtGetCategories is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) ExtGetCategories(ctx interface{}, authorID interface{}) *MockStore_ExtGetCategories_Call {
	return &MockStore_ExtGetCategories_Call{Call: _e.mock.On("ExtGetCategories", ctx, authorID)}
}

func (_c *MockStore_ExtGetCategories_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_ExtGetCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ExtGetCategories_Call) Return(extGetCategoriesRows []*store.ExtGetCategoriesRow, err error) *MockStore_ExtGetCategories_Call {
	_c.Call.Return(extGetCategoriesRows, err)
	return _c
}

func (_c *MockStore_ExtGetCategories_Call) RunAndReturn(run func(ctx context.Context, authorID string) ([]*store.ExtGetCategoriesRow, error)) *MockStore_ExtGetCategories_Call {
	_c.Call.Return(run)
	return _c
}

// GetMappingsForAuthor provides a mock function for the type MockStore
func (_mock *MockStore) GetMappingsForAuthor(ctx context.Context, authorID string) ([]*data.Mapping, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for GetMappingsForAuthor")
	}

	var r0 []*data.Mapping
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*data.Mapping, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*data.Mapping); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*data.Mapping)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetMappingsForAuthor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMappingsForAuthor'
type MockStore_GetMappingsForAuthor_Call struct {
	*mock.Call
}

// GetMappingsForAuthor is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) GetMappingsForAuthor(ctx interface{}, authorID interface{}) *MockStore_GetMappingsForAuthor_Call {
	return &MockStore_GetMappingsForAuthor_Call{Call: _e.mock.On("GetMappingsForAuthor", ctx, authorID)}
}

func (_c *MockStore_GetMappingsForAuthor_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_GetMappingsForAuthor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetMappingsForAuthor_Call) Return(mappings []*data.Mapping, err error) *MockStore_GetMappingsForAuthor_Call {
	_c.Call.Return(mappings, err)
	return _c
}

func (_c *MockStore_GetMappingsForAuthor_Call) RunAndReturn(run func(ctx context.Context, authorID string) ([]*data.Mapping, error)) *MockStore_GetMappingsForAuthor_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransCount provides a mock function for the type MockStore
func (_mock *MockStore) GetTransCount(ctx context.Context, authorID string) (int64, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetTransCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransCount'
type MockStore_GetTransCount_Call struct {
	*mock.Call
}

// GetTransCount is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) GetTransCount(ctx interface{}, authorID interface{}) *MockStore_GetTransCount_Call {
	return &MockStore_GetTransCount_Call{Call: _e.mock.On("GetTransCount", ctx, authorID)}
}

func (_c *MockStore_GetTransCount_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_GetTransCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetTransCount_Call) Return(n int64, err error) *MockStore_GetTransCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetTransCount_Call) RunAndReturn(run func(ctx context.Context, authorID string) (int64, error)) *MockStore_GetTransCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactions provides a mock function for the type MockStore
func (_mock *MockStore) GetTransactions(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool) ([]*data.Transactions, error) {
	ret := _mock.Called(ctx, authorID, amount, offset, orderColumn, asc)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactions")
	}

	var r0 []*data.Transactions
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int, string, bool) ([]*data.Transactions, error)); ok {
		return returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int, string, bool) []*data.Transactions); ok {
		r0 = returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*data.Transactions)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int, string, bool) error); ok {
		r1 = returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactions'
type MockStore_GetTransactions_Call struct {
	*mock.Call
}

// GetTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - amount int
//   - offset int
//   - orderColumn string
//   - asc bool
func (_e *MockStore_Expecter) GetTransactions(ctx interface{}, authorID interface{}, amount interface{}, offset interface{}, orderColumn interface{}, asc interface{}) *MockStore_GetTransactions_Call {
	return &MockStore_GetTransactions_Call{Call: _e.mock.On("GetTransactions", ctx, authorID, amount, offset, orderColumn, asc)}
}

func (_c *MockStore_GetTransactions_Call) Run(run func(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool)) *MockStore_GetTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 bool
		if args[5] != nil {
			arg5 = args[5].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockStore_GetTransactions_Call) Return(transactionss []*data.Transactions, err error) *MockStore_GetTransactions_Call {
	_c.Call.Return(transactionss, err)
	return _c
}

func (_c *MockStore_GetTransactions_Call) RunAndReturn(run func(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool) ([]*data.Transactions, error)) *MockStore_GetTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByName provides a mock function for the type MockStore
func (_mock *MockStore) GetUserByName(ctx context.Context, name string) (*store.User, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByName")
	}

	var r0 *store.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*store.User, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *store.User); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByName'
type MockStore_GetUserByName_Call struct {
	*mock.Call
}

// GetUserByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockStore_Expecter) GetUserByName(ctx interface{}, name interface{}) *MockStore_GetUserByName_Call {
	return &MockStore_GetUserByName_Call{Call: _e.mock.On("GetUserByName", ctx, name)}
}

func (_c *MockStore_GetUserByName_Call) Run(run func(ctx context.Context, name string)) *MockStore_GetUserByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetUserByName_Call) Return(user *store.User, err error) *MockStore_GetUserByName_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStore_GetUserByName_Call) RunAndReturn(run func(ctx context.Context, name string) (*store.User, error)) *MockStore_GetUserByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserUpdatedAt provides a mock function for the type MockStore
func (_mock *MockStore) GetUserUpdatedAt(ctx context.Context, id string) (time.Time, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserUpdatedAt")
	}

	var r0 time.Time
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (time.Time, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) time.Time); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserUpdatedAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserUpdatedAt'
type MockStore_GetUserUpdatedAt_Call struct {
	*mock.Call
}

// GetUserUpdatedAt is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetUserUpdatedAt(ctx interface{}, id interface{}) *MockStore_GetUserUpdatedAt_Call {
	return &MockStore_GetUserUpdatedAt_Call{Call: _e.mock.On("GetUserUpdatedAt", ctx, id)}
}

func (_c *MockStore_GetUserUpdatedAt_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetUserUpdatedAt_Call) Return(time1 time.Time, err error) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Return(time1, err)
	return _c
}

func (_c *MockStore_GetUserUpdatedAt_Call) RunAndReturn(run func(ctx context.Context, id string) (time.Time, error)) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Return(run)
	return _c
}

// InsertCheckpoint provides a mock function for the type MockStore
func (_mock *MockStore) InsertCheckpoint(batch *pgx.Batch, date time.Time, amt float64) {
	_mock.Called(batch, date, amt)
	return
}

// MockStore_InsertCheckpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertCheckpoint'
type MockStore_InsertCheckpoint_Call struct {
	*mock.Call
}

// InsertCheckpoint is a helper method to define mock.On call
//   - batch *pgx.Batch
//   - date time.Time
//   - amt float64
func (_e *MockStore_Expecter) InsertCheckpoint(batch interface{}, date interface{}, amt interface{}) *MockStore_InsertCheckpoint_Call {
	return &MockStore_InsertCheckpoint_Call{Call: _e.mock.On("InsertCheckpoint", batch, date, amt)}
}

func (_c *MockStore_InsertCheckpoint_Call) Run(run func(batch *pgx.Batch, date time.Time, amt float64)) *MockStore_InsertCheckpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pgx.Batch
		if args[0] != nil {
			arg0 = args[0].(*pgx.Batch)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_InsertCheckpoint_Call) Return() *MockStore_InsertCheckpoint_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStore_InsertCheckpoint_Call) RunAndReturn(run func(batch *pgx.Batch, date time.Time, amt float64)) *MockStore_InsertCheckpoint_Call {
	_c.Run(run)
	return _c
}

// InsertTransactions provides a mock function for the type MockStore
func (_mock *MockStore) InsertTransactions(ctx context.Context, b *store.TransactionBatch) (int64, error) {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for InsertTransactions")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.TransactionBatch) (int64, error)); ok {
		return returnFunc(ctx, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.TransactionBatch) int64); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *store.TransactionBatch) error); ok {
		r1 = returnFunc(ctx, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_InsertTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertTransactions'
type MockStore_InsertTransactions_Call struct {
	*mock.Call
}

// InsertTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - b *store.TransactionBatch
func (_e *MockStore_Expecter) InsertTransactions(ctx interface{}, b interface{}) *MockStore_InsertTransactions_Call {
	return &MockStore_InsertTransactions_Call{Call: _e.mock.On("InsertTransactions", ctx, b)}
}

func (_c *MockStore_InsertTransactions_Call) Run(run func(ctx context.Context, b *store.TransactionBatch)) *MockStore_InsertTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *store.TransactionBatch
		if args[1] != nil {
			arg1 = args[1].(*store.TransactionBatch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_InsertTransactions_Call) Return(n int64, err error) *MockStore_InsertTransactions_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_InsertTransactions_Call) RunAndReturn(run func(ctx context.Context, b *store.TransactionBatch) (int64, error)) *MockStore_InsertTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// NewUser provides a mock function for the type MockStore
func (_mock *MockStore) NewUser(ctx context.Context, username string, password []byte) (string, error) {
	ret := _mock.Called(ctx, username, password)

	if len(ret) == 0 {
		panic("no return value specified for NewUser")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) (string, error)); ok {
		return returnFunc(ctx, username, password)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) string); ok {
		r0 = returnFunc(ctx, username, password)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []byte) error); ok {
		r1 = returnFunc(ctx, username, password)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_NewUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUser'
type MockStore_NewUser_Call struct {
	*mock.Call
}

// NewUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - password []byte
func (_e *MockStore_Expecter) NewUser(ctx interface{}, username interface{}, password interface{}) *MockStore_NewUser_Call {
	return &MockStore_NewUser_Call{Call: _e.mock.On("NewUser", ctx, username, password)}
}

func (_c *MockStore_NewUser_Call) Run(run func(ctx context.Context, username string, password []byte)) *MockStore_NewUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_NewUser_Call) Return(s string, err error) *MockStore_NewUser_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockStore_NewUser_Call) RunAndReturn(run func(ctx context.Context, username string, password []byte) (string, error)) *MockStore_NewUser_Call {
	_c.Call.Return(run)
	return _c
}

// SendBatch provides a mock function for the type MockStore
func (_mock *MockStore) SendBatch(ctx context.Context, b *pgx.Batch) error {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for SendBatch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pgx.Batch) error); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SendBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendBatch'
type MockStore_SendBatch_Call struct {
	*mock.Call
}

// SendBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - b *pgx.Batch
func (_e *MockStore_Expecter) SendBatch(ctx interface{}, b interface{}) *MockStore_SendBatch_Call {
	return &MockStore_SendBatch_Call{Call: _e.mock.On("SendBatch", ctx, b)}
}

func (_c *MockStore_SendBatch_Call) Run(run func(ctx context.Context, b *pgx.Batch)) *MockStore_SendBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pgx.Batch
		if args[1] != nil {
			arg1 = args[1].(*pgx.Batch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_SendBatch_Call) Return(err error) *MockStore_SendBatch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SendBatch_Call) RunAndReturn(run func(ctx context.Context, b *pgx.Batch) error) *MockStore_SendBatch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTransCatsUsingMapping provides a mock function for the type MockStore
func (_mock *MockStore) UpdateTransCatsUsingMapping(ctx context.Context, newCategoryID string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp) (int, error) {
	ret := _mock.Called(ctx, newCategoryID, authorID, amtMatcher, txtMatcher)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransCatsUsingMapping")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *float64, *regexp.Regexp) (int, error)); ok {
		return returnFunc(ctx, newCategoryID, authorID, amtMatcher, txtMatcher)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *float64, *regexp.Regexp) int); ok {
		r0 = returnFunc(ctx, newCategoryID, authorID, amtMatcher, txtMatcher)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, *float64, *regexp.Regexp) error); ok {
		r1 = returnFunc(ctx, newCategoryID, authorID, amtMatcher, txtMatcher)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_UpdateTransCatsUsingMapping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTransCatsUsingMapping'
type MockStore_UpdateTransCatsUsingMapping_Call struct {
	*mock.Call
}

// UpdateTransCatsUsingMapping is a helper method to define mock.On call
//   - ctx context.Context
//   - newCategoryID string
//   - authorID string
//   - amtMatcher *float64
//   - txtMatcher *regexp.Regexp
func (_e *MockStore_Expecter) UpdateTransCatsUsingMapping(ctx interface{}, newCategoryID interface{}, authorID interface{}, amtMatcher interface{}, txtMatcher interface{}) *MockStore_UpdateTransCatsUsingMapping_Call {
	return &MockStore_UpdateTransCatsUsingMapping_Call{Call: _e.mock.On("UpdateTransCatsUsingMapping", ctx, newCategoryID, authorID, amtMatcher, txtMatcher)}
}

func (_c *MockStore_UpdateTransCatsUsingMapping_Call) Run(run func(ctx context.Context, newCategoryID string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp)) *MockStore_UpdateTransCatsUsingMapping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 *float64
		if args[3] != nil {
			arg3 = args[3].(*float64)
		}
		var arg4 *regexp.Regexp
		if args[4] != nil {
			arg4 = args[4].(*regexp.Regexp)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateTransCatsUsingMapping_Call) Return(n int, err error) *MockStore_UpdateTransCatsUsingMapping_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_UpdateTransCatsUsingMapping_Call) RunAndReturn(run func(ctx context.Context, newCategoryID string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp) (int, error)) *MockStore_UpdateTransCatsUsingMapping_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTransNamesUsingMapping provides a mock function for the type MockStore
func (_mock *MockStore) UpdateTransNamesUsingMapping(ctx context.Context, newName string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp) (int, error) {
	ret := _mock.Called(ctx, newName, authorID, amtMatcher, txtMatcher)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransNamesUsingMapping")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *float64, *regexp.Regexp) (int, error)); ok {
		return returnFunc(ctx, newName, authorID, amtMatcher, txtMatcher)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *float64, *regexp.Regexp) int); ok {
		r0 = returnFunc(ctx, newName, authorID, amtMatcher, txtMatcher)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, *float64, *regexp.Regexp) error); ok {
		r1 = returnFunc(ctx, newName, authorID, amtMatcher, txtMatcher)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_UpdateTransNamesUsingMapping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTransNamesUsingMapping'
type MockStore_UpdateTransNamesUsingMapping_Call struct {
	*mock.Call
}

// UpdateTransNamesUsingMapping is a helper method to define mock.On call
//   - ctx context.Context
//   - newName string
//   - authorID string
//   - amtMatcher *float64
//   - txtMatcher *regexp.Regexp
func (_e *MockStore_Expecter) UpdateTransNamesUsingMapping(ctx interface{}, newName interface{}, authorID interface{}, amtMatcher interface{}, txtMatcher interface{}) *MockStore_UpdateTransNamesUsingMapping_Call {
	return &MockStore_UpdateTransNamesUsingMapping_Call{Call: _e.mock.On("UpdateTransNamesUsingMapping", ctx, newName, authorID, amtMatcher, txtMatcher)}
}

func (_c *MockStore_UpdateTransNamesUsingMapping_Call) Run(run func(ctx context.Context, newName string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp)) *MockStore_UpdateTransNamesUsingMapping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 *float64
		if args[3] != nil {
			arg3 = args[3].(*float64)
		}
		var arg4 *regexp.Regexp
		if args[4] != nil {
			arg4 = args[4].(*regexp.Regexp)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateTransNamesUsingMapping_Call) Return(n int, err error) *MockStore_UpdateTransNamesUsingMapping_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_UpdateTransNamesUsingMapping_Call) RunAndReturn(run func(ctx context.Context, newName string, authorID string, amtMatcher *float64, txtMatcher *regexp.Regexp) (int, error)) *MockStore_UpdateTransNamesUsingMapping_Call {
	_c.Call.Return(run)
	return _c
}
