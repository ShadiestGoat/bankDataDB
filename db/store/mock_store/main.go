// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock_store

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/shadiestgoat/bankDataDB/data"
	"github.com/shadiestgoat/bankDataDB/db/store"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// DoesCategoryExist provides a mock function for the type MockStore
func (_mock *MockStore) DoesCategoryExist(ctx context.Context, authorID string, iD string) (bool, error) {
	ret := _mock.Called(ctx, authorID, iD)

	if len(ret) == 0 {
		panic("no return value specified for DoesCategoryExist")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, authorID, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, authorID, iD)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DoesCategoryExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesCategoryExist'
type MockStore_DoesCategoryExist_Call struct {
	*mock.Call
}

// DoesCategoryExist is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - iD string
func (_e *MockStore_Expecter) DoesCategoryExist(ctx interface{}, authorID interface{}, iD interface{}) *MockStore_DoesCategoryExist_Call {
	return &MockStore_DoesCategoryExist_Call{Call: _e.mock.On("DoesCategoryExist", ctx, authorID, iD)}
}

func (_c *MockStore_DoesCategoryExist_Call) Run(run func(ctx context.Context, authorID string, iD string)) *MockStore_DoesCategoryExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_DoesCategoryExist_Call) Return(b bool, err error) *MockStore_DoesCategoryExist_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_DoesCategoryExist_Call) RunAndReturn(run func(ctx context.Context, authorID string, iD string) (bool, error)) *MockStore_DoesCategoryExist_Call {
	_c.Call.Return(run)
	return _c
}

// DoesMappingExist provides a mock function for the type MockStore
func (_mock *MockStore) DoesMappingExist(ctx context.Context, authorID string, iD string) (bool, error) {
	ret := _mock.Called(ctx, authorID, iD)

	if len(ret) == 0 {
		panic("no return value specified for DoesMappingExist")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, authorID, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, authorID, iD)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DoesMappingExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesMappingExist'
type MockStore_DoesMappingExist_Call struct {
	*mock.Call
}

// DoesMappingExist is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - iD string
func (_e *MockStore_Expecter) DoesMappingExist(ctx interface{}, authorID interface{}, iD interface{}) *MockStore_DoesMappingExist_Call {
	return &MockStore_DoesMappingExist_Call{Call: _e.mock.On("DoesMappingExist", ctx, authorID, iD)}
}

func (_c *MockStore_DoesMappingExist_Call) Run(run func(ctx context.Context, authorID string, iD string)) *MockStore_DoesMappingExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_DoesMappingExist_Call) Return(b bool, err error) *MockStore_DoesMappingExist_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_DoesMappingExist_Call) RunAndReturn(run func(ctx context.Context, authorID string, iD string) (bool, error)) *MockStore_DoesMappingExist_Call {
	_c.Call.Return(run)
	return _c
}

// DoesTransactionExist provides a mock function for the type MockStore
func (_mock *MockStore) DoesTransactionExist(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64) (bool, error) {
	ret := _mock.Called(ctx, authorID, authedAt, settledAt, description, amount)

	if len(ret) == 0 {
		panic("no return value specified for DoesTransactionExist")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time, string, float64) (bool, error)); ok {
		return returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time, string, float64) bool); ok {
		r0 = returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, time.Time, time.Time, string, float64) error); ok {
		r1 = returnFunc(ctx, authorID, authedAt, settledAt, description, amount)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DoesTransactionExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesTransactionExist'
type MockStore_DoesTransactionExist_Call struct {
	*mock.Call
}

// DoesTransactionExist is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - authedAt time.Time
//   - settledAt time.Time
//   - description string
//   - amount float64
func (_e *MockStore_Expecter) DoesTransactionExist(ctx interface{}, authorID interface{}, authedAt interface{}, settledAt interface{}, description interface{}, amount interface{}) *MockStore_DoesTransactionExist_Call {
	return &MockStore_DoesTransactionExist_Call{Call: _e.mock.On("DoesTransactionExist", ctx, authorID, authedAt, settledAt, description, amount)}
}

func (_c *MockStore_DoesTransactionExist_Call) Run(run func(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64)) *MockStore_DoesTransactionExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 float64
		if args[5] != nil {
			arg5 = args[5].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockStore_DoesTransactionExist_Call) Return(b bool, err error) *MockStore_DoesTransactionExist_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_DoesTransactionExist_Call) RunAndReturn(run func(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64) (bool, error)) *MockStore_DoesTransactionExist_Call {
	_c.Call.Return(run)
	return _c
}

// ExtDelCategory provides a mock function for the type MockStore
func (_mock *MockStore) ExtDelCategory(ctx context.Context, authorID string, iD string) (int64, error) {
	ret := _mock.Called(ctx, authorID, iD)

	if len(ret) == 0 {
		panic("no return value specified for ExtDelCategory")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (int64, error)); ok {
		return returnFunc(ctx, authorID, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) int64); ok {
		r0 = returnFunc(ctx, authorID, iD)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ExtDelCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtDelCategory'
type MockStore_ExtDelCategory_Call struct {
	*mock.Call
}

// ExtDelCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - iD string
func (_e *MockStore_Expecter) ExtDelCategory(ctx interface{}, authorID interface{}, iD interface{}) *MockStore_ExtDelCategory_Call {
	return &MockStore_ExtDelCategory_Call{Call: _e.mock.On("ExtDelCategory", ctx, authorID, iD)}
}

func (_c *MockStore_ExtDelCategory_Call) Run(run func(ctx context.Context, authorID string, iD string)) *MockStore_ExtDelCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_ExtDelCategory_Call) Return(n int64, err error) *MockStore_ExtDelCategory_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_ExtDelCategory_Call) RunAndReturn(run func(ctx context.Context, authorID string, iD string) (int64, error)) *MockStore_ExtDelCategory_Call {
	_c.Call.Return(run)
	return _c
}

// ExtGetCategories provides a mock function for the type MockStore
func (_mock *MockStore) ExtGetCategories(ctx context.Context, authorID string) ([]*store.ExtGetCategoriesRow, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for ExtGetCategories")
	}

	var r0 []*store.ExtGetCategoriesRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*store.ExtGetCategoriesRow, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*store.ExtGetCategoriesRow); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*store.ExtGetCategoriesRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ExtGetCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtGetCategories'
type MockStore_ExtGetCategories_Call struct {
	*mock.Call
}

// ExtGetCategories is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) ExtGetCategories(ctx interface{}, authorID interface{}) *MockStore_ExtGetCategories_Call {
	return &MockStore_ExtGetCategories_Call{Call: _e.mock.On("ExtGetCategories", ctx, authorID)}
}

func (_c *MockStore_ExtGetCategories_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_ExtGetCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ExtGetCategories_Call) Return(extGetCategoriesRows []*store.ExtGetCategoriesRow, err error) *MockStore_ExtGetCategories_Call {
	_c.Call.Return(extGetCategoriesRows, err)
	return _c
}

func (_c *MockStore_ExtGetCategories_Call) RunAndReturn(run func(ctx context.Context, authorID string) ([]*store.ExtGetCategoriesRow, error)) *MockStore_ExtGetCategories_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransCount provides a mock function for the type MockStore
func (_mock *MockStore) GetTransCount(ctx context.Context, authorID string) (int64, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetTransCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransCount'
type MockStore_GetTransCount_Call struct {
	*mock.Call
}

// GetTransCount is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) GetTransCount(ctx interface{}, authorID interface{}) *MockStore_GetTransCount_Call {
	return &MockStore_GetTransCount_Call{Call: _e.mock.On("GetTransCount", ctx, authorID)}
}

func (_c *MockStore_GetTransCount_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_GetTransCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetTransCount_Call) Return(n int64, err error) *MockStore_GetTransCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetTransCount_Call) RunAndReturn(run func(ctx context.Context, authorID string) (int64, error)) *MockStore_GetTransCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactions provides a mock function for the type MockStore
func (_mock *MockStore) GetTransactions(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool) ([]*data.Transactions, error) {
	ret := _mock.Called(ctx, authorID, amount, offset, orderColumn, asc)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactions")
	}

	var r0 []*data.Transactions
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int, string, bool) ([]*data.Transactions, error)); ok {
		return returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int, string, bool) []*data.Transactions); ok {
		r0 = returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*data.Transactions)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int, string, bool) error); ok {
		r1 = returnFunc(ctx, authorID, amount, offset, orderColumn, asc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactions'
type MockStore_GetTransactions_Call struct {
	*mock.Call
}

// GetTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - amount int
//   - offset int
//   - orderColumn string
//   - asc bool
func (_e *MockStore_Expecter) GetTransactions(ctx interface{}, authorID interface{}, amount interface{}, offset interface{}, orderColumn interface{}, asc interface{}) *MockStore_GetTransactions_Call {
	return &MockStore_GetTransactions_Call{Call: _e.mock.On("GetTransactions", ctx, authorID, amount, offset, orderColumn, asc)}
}

func (_c *MockStore_GetTransactions_Call) Run(run func(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool)) *MockStore_GetTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 bool
		if args[5] != nil {
			arg5 = args[5].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockStore_GetTransactions_Call) Return(transactionss []*data.Transactions, err error) *MockStore_GetTransactions_Call {
	_c.Call.Return(transactionss, err)
	return _c
}

func (_c *MockStore_GetTransactions_Call) RunAndReturn(run func(ctx context.Context, authorID string, amount int, offset int, orderColumn string, asc bool) ([]*data.Transactions, error)) *MockStore_GetTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByName provides a mock function for the type MockStore
func (_mock *MockStore) GetUserByName(ctx context.Context, name string) (*store.User, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByName")
	}

	var r0 *store.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*store.User, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *store.User); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByName'
type MockStore_GetUserByName_Call struct {
	*mock.Call
}

// GetUserByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockStore_Expecter) GetUserByName(ctx interface{}, name interface{}) *MockStore_GetUserByName_Call {
	return &MockStore_GetUserByName_Call{Call: _e.mock.On("GetUserByName", ctx, name)}
}

func (_c *MockStore_GetUserByName_Call) Run(run func(ctx context.Context, name string)) *MockStore_GetUserByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetUserByName_Call) Return(user *store.User, err error) *MockStore_GetUserByName_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStore_GetUserByName_Call) RunAndReturn(run func(ctx context.Context, name string) (*store.User, error)) *MockStore_GetUserByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserUpdatedAt provides a mock function for the type MockStore
func (_mock *MockStore) GetUserUpdatedAt(ctx context.Context, id string) (time.Time, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserUpdatedAt")
	}

	var r0 time.Time
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (time.Time, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) time.Time); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserUpdatedAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserUpdatedAt'
type MockStore_GetUserUpdatedAt_Call struct {
	*mock.Call
}

// GetUserUpdatedAt is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetUserUpdatedAt(ctx interface{}, id interface{}) *MockStore_GetUserUpdatedAt_Call {
	return &MockStore_GetUserUpdatedAt_Call{Call: _e.mock.On("GetUserUpdatedAt", ctx, id)}
}

func (_c *MockStore_GetUserUpdatedAt_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetUserUpdatedAt_Call) Return(time1 time.Time, err error) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Return(time1, err)
	return _c
}

func (_c *MockStore_GetUserUpdatedAt_Call) RunAndReturn(run func(ctx context.Context, id string) (time.Time, error)) *MockStore_GetUserUpdatedAt_Call {
	_c.Call.Return(run)
	return _c
}

// InsertCheckpoint provides a mock function for the type MockStore
func (_mock *MockStore) InsertCheckpoint(batch *pgx.Batch, date time.Time, amt float64) {
	_mock.Called(batch, date, amt)
	return
}

// MockStore_InsertCheckpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertCheckpoint'
type MockStore_InsertCheckpoint_Call struct {
	*mock.Call
}

// InsertCheckpoint is a helper method to define mock.On call
//   - batch *pgx.Batch
//   - date time.Time
//   - amt float64
func (_e *MockStore_Expecter) InsertCheckpoint(batch interface{}, date interface{}, amt interface{}) *MockStore_InsertCheckpoint_Call {
	return &MockStore_InsertCheckpoint_Call{Call: _e.mock.On("InsertCheckpoint", batch, date, amt)}
}

func (_c *MockStore_InsertCheckpoint_Call) Run(run func(batch *pgx.Batch, date time.Time, amt float64)) *MockStore_InsertCheckpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pgx.Batch
		if args[0] != nil {
			arg0 = args[0].(*pgx.Batch)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_InsertCheckpoint_Call) Return() *MockStore_InsertCheckpoint_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStore_InsertCheckpoint_Call) RunAndReturn(run func(batch *pgx.Batch, date time.Time, amt float64)) *MockStore_InsertCheckpoint_Call {
	_c.Run(run)
	return _c
}

// InsertTransactions provides a mock function for the type MockStore
func (_mock *MockStore) InsertTransactions(ctx context.Context, b *store.TransactionBatch) (int64, error) {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for InsertTransactions")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.TransactionBatch) (int64, error)); ok {
		return returnFunc(ctx, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.TransactionBatch) int64); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *store.TransactionBatch) error); ok {
		r1 = returnFunc(ctx, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_InsertTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertTransactions'
type MockStore_InsertTransactions_Call struct {
	*mock.Call
}

// InsertTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - b *store.TransactionBatch
func (_e *MockStore_Expecter) InsertTransactions(ctx interface{}, b interface{}) *MockStore_InsertTransactions_Call {
	return &MockStore_InsertTransactions_Call{Call: _e.mock.On("InsertTransactions", ctx, b)}
}

func (_c *MockStore_InsertTransactions_Call) Run(run func(ctx context.Context, b *store.TransactionBatch)) *MockStore_InsertTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *store.TransactionBatch
		if args[1] != nil {
			arg1 = args[1].(*store.TransactionBatch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_InsertTransactions_Call) Return(n int64, err error) *MockStore_InsertTransactions_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_InsertTransactions_Call) RunAndReturn(run func(ctx context.Context, b *store.TransactionBatch) (int64, error)) *MockStore_InsertTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// MappingDelete provides a mock function for the type MockStore
func (_mock *MockStore) MappingDelete(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for MappingDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_MappingDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappingDelete'
type MockStore_MappingDelete_Call struct {
	*mock.Call
}

// MappingDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) MappingDelete(ctx interface{}, id interface{}) *MockStore_MappingDelete_Call {
	return &MockStore_MappingDelete_Call{Call: _e.mock.On("MappingDelete", ctx, id)}
}

func (_c *MockStore_MappingDelete_Call) Run(run func(ctx context.Context, id string)) *MockStore_MappingDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_MappingDelete_Call) Return(err error) *MockStore_MappingDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_MappingDelete_Call) RunAndReturn(run func(ctx context.Context, id string) error) *MockStore_MappingDelete_Call {
	_c.Call.Return(run)
	return _c
}

// MappingGetAll provides a mock function for the type MockStore
func (_mock *MockStore) MappingGetAll(ctx context.Context, authorID string) ([]*data.Mapping, error) {
	ret := _mock.Called(ctx, authorID)

	if len(ret) == 0 {
		panic("no return value specified for MappingGetAll")
	}

	var r0 []*data.Mapping
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*data.Mapping, error)); ok {
		return returnFunc(ctx, authorID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*data.Mapping); ok {
		r0 = returnFunc(ctx, authorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*data.Mapping)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, authorID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_MappingGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappingGetAll'
type MockStore_MappingGetAll_Call struct {
	*mock.Call
}

// MappingGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
func (_e *MockStore_Expecter) MappingGetAll(ctx interface{}, authorID interface{}) *MockStore_MappingGetAll_Call {
	return &MockStore_MappingGetAll_Call{Call: _e.mock.On("MappingGetAll", ctx, authorID)}
}

func (_c *MockStore_MappingGetAll_Call) Run(run func(ctx context.Context, authorID string)) *MockStore_MappingGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_MappingGetAll_Call) Return(mappings []*data.Mapping, err error) *MockStore_MappingGetAll_Call {
	_c.Call.Return(mappings, err)
	return _c
}

func (_c *MockStore_MappingGetAll_Call) RunAndReturn(run func(ctx context.Context, authorID string) ([]*data.Mapping, error)) *MockStore_MappingGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// MappingGetByID provides a mock function for the type MockStore
func (_mock *MockStore) MappingGetByID(ctx context.Context, authorID string, mappingID string) (*data.Mapping, error) {
	ret := _mock.Called(ctx, authorID, mappingID)

	if len(ret) == 0 {
		panic("no return value specified for MappingGetByID")
	}

	var r0 *data.Mapping
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*data.Mapping, error)); ok {
		return returnFunc(ctx, authorID, mappingID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *data.Mapping); ok {
		r0 = returnFunc(ctx, authorID, mappingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*data.Mapping)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, mappingID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_MappingGetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappingGetByID'
type MockStore_MappingGetByID_Call struct {
	*mock.Call
}

// MappingGetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - mappingID string
func (_e *MockStore_Expecter) MappingGetByID(ctx interface{}, authorID interface{}, mappingID interface{}) *MockStore_MappingGetByID_Call {
	return &MockStore_MappingGetByID_Call{Call: _e.mock.On("MappingGetByID", ctx, authorID, mappingID)}
}

func (_c *MockStore_MappingGetByID_Call) Run(run func(ctx context.Context, authorID string, mappingID string)) *MockStore_MappingGetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_MappingGetByID_Call) Return(mapping *data.Mapping, err error) *MockStore_MappingGetByID_Call {
	_c.Call.Return(mapping, err)
	return _c
}

func (_c *MockStore_MappingGetByID_Call) RunAndReturn(run func(ctx context.Context, authorID string, mappingID string) (*data.Mapping, error)) *MockStore_MappingGetByID_Call {
	_c.Call.Return(run)
	return _c
}

// MappingInsert provides a mock function for the type MockStore
func (_mock *MockStore) MappingInsert(ctx context.Context, authorID string, m *data.Mapping) (string, error) {
	ret := _mock.Called(ctx, authorID, m)

	if len(ret) == 0 {
		panic("no return value specified for MappingInsert")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *data.Mapping) (string, error)); ok {
		return returnFunc(ctx, authorID, m)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *data.Mapping) string); ok {
		r0 = returnFunc(ctx, authorID, m)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *data.Mapping) error); ok {
		r1 = returnFunc(ctx, authorID, m)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_MappingInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappingInsert'
type MockStore_MappingInsert_Call struct {
	*mock.Call
}

// MappingInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - m *data.Mapping
func (_e *MockStore_Expecter) MappingInsert(ctx interface{}, authorID interface{}, m interface{}) *MockStore_MappingInsert_Call {
	return &MockStore_MappingInsert_Call{Call: _e.mock.On("MappingInsert", ctx, authorID, m)}
}

func (_c *MockStore_MappingInsert_Call) Run(run func(ctx context.Context, authorID string, m *data.Mapping)) *MockStore_MappingInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *data.Mapping
		if args[2] != nil {
			arg2 = args[2].(*data.Mapping)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_MappingInsert_Call) Return(s string, err error) *MockStore_MappingInsert_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockStore_MappingInsert_Call) RunAndReturn(run func(ctx context.Context, authorID string, m *data.Mapping) (string, error)) *MockStore_MappingInsert_Call {
	_c.Call.Return(run)
	return _c
}

// MappingReset provides a mock function for the type MockStore
func (_mock *MockStore) MappingReset(ctx context.Context, arg *store.MappingResetParams) error {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for MappingReset")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.MappingResetParams) error); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_MappingReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappingReset'
type MockStore_MappingReset_Call struct {
	*mock.Call
}

// MappingReset is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *store.MappingResetParams
func (_e *MockStore_Expecter) MappingReset(ctx interface{}, arg interface{}) *MockStore_MappingReset_Call {
	return &MockStore_MappingReset_Call{Call: _e.mock.On("MappingReset", ctx, arg)}
}

func (_c *MockStore_MappingReset_Call) Run(run func(ctx context.Context, arg *store.MappingResetParams)) *MockStore_MappingReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *store.MappingResetParams
		if args[1] != nil {
			arg1 = args[1].(*store.MappingResetParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_MappingReset_Call) Return(err error) *MockStore_MappingReset_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_MappingReset_Call) RunAndReturn(run func(ctx context.Context, arg *store.MappingResetParams) error) *MockStore_MappingReset_Call {
	_c.Call.Return(run)
	return _c
}

// NewCategory provides a mock function for the type MockStore
func (_mock *MockStore) NewCategory(ctx context.Context, authorID string, name string, icon string, color string) (string, error) {
	ret := _mock.Called(ctx, authorID, name, icon, color)

	if len(ret) == 0 {
		panic("no return value specified for NewCategory")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (string, error)); ok {
		return returnFunc(ctx, authorID, name, icon, color)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) string); ok {
		r0 = returnFunc(ctx, authorID, name, icon, color)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, authorID, name, icon, color)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_NewCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewCategory'
type MockStore_NewCategory_Call struct {
	*mock.Call
}

// NewCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - name string
//   - icon string
//   - color string
func (_e *MockStore_Expecter) NewCategory(ctx interface{}, authorID interface{}, name interface{}, icon interface{}, color interface{}) *MockStore_NewCategory_Call {
	return &MockStore_NewCategory_Call{Call: _e.mock.On("NewCategory", ctx, authorID, name, icon, color)}
}

func (_c *MockStore_NewCategory_Call) Run(run func(ctx context.Context, authorID string, name string, icon string, color string)) *MockStore_NewCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_NewCategory_Call) Return(s string, err error) *MockStore_NewCategory_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockStore_NewCategory_Call) RunAndReturn(run func(ctx context.Context, authorID string, name string, icon string, color string) (string, error)) *MockStore_NewCategory_Call {
	_c.Call.Return(run)
	return _c
}

// NewUser provides a mock function for the type MockStore
func (_mock *MockStore) NewUser(ctx context.Context, username string, password []byte) (string, error) {
	ret := _mock.Called(ctx, username, password)

	if len(ret) == 0 {
		panic("no return value specified for NewUser")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) (string, error)); ok {
		return returnFunc(ctx, username, password)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) string); ok {
		r0 = returnFunc(ctx, username, password)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []byte) error); ok {
		r1 = returnFunc(ctx, username, password)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_NewUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUser'
type MockStore_NewUser_Call struct {
	*mock.Call
}

// NewUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - password []byte
func (_e *MockStore_Expecter) NewUser(ctx interface{}, username interface{}, password interface{}) *MockStore_NewUser_Call {
	return &MockStore_NewUser_Call{Call: _e.mock.On("NewUser", ctx, username, password)}
}

func (_c *MockStore_NewUser_Call) Run(run func(ctx context.Context, username string, password []byte)) *MockStore_NewUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_NewUser_Call) Return(s string, err error) *MockStore_NewUser_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockStore_NewUser_Call) RunAndReturn(run func(ctx context.Context, username string, password []byte) (string, error)) *MockStore_NewUser_Call {
	_c.Call.Return(run)
	return _c
}

// ResetCategoryData provides a mock function for the type MockStore
func (_mock *MockStore) ResetCategoryData(ctx context.Context, iD string, name string, color string, icon string) error {
	ret := _mock.Called(ctx, iD, name, color, icon)

	if len(ret) == 0 {
		panic("no return value specified for ResetCategoryData")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = returnFunc(ctx, iD, name, color, icon)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ResetCategoryData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetCategoryData'
type MockStore_ResetCategoryData_Call struct {
	*mock.Call
}

// ResetCategoryData is a helper method to define mock.On call
//   - ctx context.Context
//   - iD string
//   - name string
//   - color string
//   - icon string
func (_e *MockStore_Expecter) ResetCategoryData(ctx interface{}, iD interface{}, name interface{}, color interface{}, icon interface{}) *MockStore_ResetCategoryData_Call {
	return &MockStore_ResetCategoryData_Call{Call: _e.mock.On("ResetCategoryData", ctx, iD, name, color, icon)}
}

func (_c *MockStore_ResetCategoryData_Call) Run(run func(ctx context.Context, iD string, name string, color string, icon string)) *MockStore_ResetCategoryData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_ResetCategoryData_Call) Return(err error) *MockStore_ResetCategoryData_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ResetCategoryData_Call) RunAndReturn(run func(ctx context.Context, iD string, name string, color string, icon string) error) *MockStore_ResetCategoryData_Call {
	_c.Call.Return(run)
	return _c
}

// SendBatch provides a mock function for the type MockStore
func (_mock *MockStore) SendBatch(ctx context.Context, b *pgx.Batch) error {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for SendBatch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pgx.Batch) error); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SendBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendBatch'
type MockStore_SendBatch_Call struct {
	*mock.Call
}

// SendBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - b *pgx.Batch
func (_e *MockStore_Expecter) SendBatch(ctx interface{}, b interface{}) *MockStore_SendBatch_Call {
	return &MockStore_SendBatch_Call{Call: _e.mock.On("SendBatch", ctx, b)}
}

func (_c *MockStore_SendBatch_Call) Run(run func(ctx context.Context, b *pgx.Batch)) *MockStore_SendBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pgx.Batch
		if args[1] != nil {
			arg1 = args[1].(*pgx.Batch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_SendBatch_Call) Return(err error) *MockStore_SendBatch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SendBatch_Call) RunAndReturn(run func(ctx context.Context, b *pgx.Batch) error) *MockStore_SendBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsCleanAll provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsCleanAll(ctx context.Context, mappingID string) error {
	ret := _mock.Called(ctx, mappingID)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsCleanAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, mappingID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsCleanAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsCleanAll'
type MockStore_TransMapsCleanAll_Call struct {
	*mock.Call
}

// TransMapsCleanAll is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
func (_e *MockStore_Expecter) TransMapsCleanAll(ctx interface{}, mappingID interface{}) *MockStore_TransMapsCleanAll_Call {
	return &MockStore_TransMapsCleanAll_Call{Call: _e.mock.On("TransMapsCleanAll", ctx, mappingID)}
}

func (_c *MockStore_TransMapsCleanAll_Call) Run(run func(ctx context.Context, mappingID string)) *MockStore_TransMapsCleanAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsCleanAll_Call) Return(err error) *MockStore_TransMapsCleanAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsCleanAll_Call) RunAndReturn(run func(ctx context.Context, mappingID string) error) *MockStore_TransMapsCleanAll_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsInsert provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsInsert(ctx context.Context, transIDs []string, mappingID string, mappedName bool) error {
	ret := _mock.Called(ctx, transIDs, mappingID, mappedName)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsInsert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, bool) error); ok {
		r0 = returnFunc(ctx, transIDs, mappingID, mappedName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsInsert'
type MockStore_TransMapsInsert_Call struct {
	*mock.Call
}

// TransMapsInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - transIDs []string
//   - mappingID string
//   - mappedName bool
func (_e *MockStore_Expecter) TransMapsInsert(ctx interface{}, transIDs interface{}, mappingID interface{}, mappedName interface{}) *MockStore_TransMapsInsert_Call {
	return &MockStore_TransMapsInsert_Call{Call: _e.mock.On("TransMapsInsert", ctx, transIDs, mappingID, mappedName)}
}

func (_c *MockStore_TransMapsInsert_Call) Run(run func(ctx context.Context, transIDs []string, mappingID string, mappedName bool)) *MockStore_TransMapsInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsInsert_Call) Return(err error) *MockStore_TransMapsInsert_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsInsert_Call) RunAndReturn(run func(ctx context.Context, transIDs []string, mappingID string, mappedName bool) error) *MockStore_TransMapsInsert_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsInsertBatch provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsInsertBatch(ctx context.Context, b *store.TransMapsBatch) error {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsInsertBatch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *store.TransMapsBatch) error); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsInsertBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsInsertBatch'
type MockStore_TransMapsInsertBatch_Call struct {
	*mock.Call
}

// TransMapsInsertBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - b *store.TransMapsBatch
func (_e *MockStore_Expecter) TransMapsInsertBatch(ctx interface{}, b interface{}) *MockStore_TransMapsInsertBatch_Call {
	return &MockStore_TransMapsInsertBatch_Call{Call: _e.mock.On("TransMapsInsertBatch", ctx, b)}
}

func (_c *MockStore_TransMapsInsertBatch_Call) Run(run func(ctx context.Context, b *store.TransMapsBatch)) *MockStore_TransMapsInsertBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *store.TransMapsBatch
		if args[1] != nil {
			arg1 = args[1].(*store.TransMapsBatch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsInsertBatch_Call) Return(err error) *MockStore_TransMapsInsertBatch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsInsertBatch_Call) RunAndReturn(run func(ctx context.Context, b *store.TransMapsBatch) error) *MockStore_TransMapsInsertBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsMapExisting provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsMapExisting(ctx context.Context, updateName bool, authorID string, m *data.Mapping) (int, error) {
	ret := _mock.Called(ctx, updateName, authorID, m)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsMapExisting")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool, string, *data.Mapping) (int, error)); ok {
		return returnFunc(ctx, updateName, authorID, m)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool, string, *data.Mapping) int); ok {
		r0 = returnFunc(ctx, updateName, authorID, m)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bool, string, *data.Mapping) error); ok {
		r1 = returnFunc(ctx, updateName, authorID, m)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_TransMapsMapExisting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsMapExisting'
type MockStore_TransMapsMapExisting_Call struct {
	*mock.Call
}

// TransMapsMapExisting is a helper method to define mock.On call
//   - ctx context.Context
//   - updateName bool
//   - authorID string
//   - m *data.Mapping
func (_e *MockStore_Expecter) TransMapsMapExisting(ctx interface{}, updateName interface{}, authorID interface{}, m interface{}) *MockStore_TransMapsMapExisting_Call {
	return &MockStore_TransMapsMapExisting_Call{Call: _e.mock.On("TransMapsMapExisting", ctx, updateName, authorID, m)}
}

func (_c *MockStore_TransMapsMapExisting_Call) Run(run func(ctx context.Context, updateName bool, authorID string, m *data.Mapping)) *MockStore_TransMapsMapExisting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 *data.Mapping
		if args[3] != nil {
			arg3 = args[3].(*data.Mapping)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsMapExisting_Call) Return(n int, err error) *MockStore_TransMapsMapExisting_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_TransMapsMapExisting_Call) RunAndReturn(run func(ctx context.Context, updateName bool, authorID string, m *data.Mapping) (int, error)) *MockStore_TransMapsMapExisting_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsOrphanAll provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsOrphanAll(ctx context.Context, mappingID string) error {
	ret := _mock.Called(ctx, mappingID)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsOrphanAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, mappingID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsOrphanAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsOrphanAll'
type MockStore_TransMapsOrphanAll_Call struct {
	*mock.Call
}

// TransMapsOrphanAll is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
func (_e *MockStore_Expecter) TransMapsOrphanAll(ctx interface{}, mappingID interface{}) *MockStore_TransMapsOrphanAll_Call {
	return &MockStore_TransMapsOrphanAll_Call{Call: _e.mock.On("TransMapsOrphanAll", ctx, mappingID)}
}

func (_c *MockStore_TransMapsOrphanAll_Call) Run(run func(ctx context.Context, mappingID string)) *MockStore_TransMapsOrphanAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsOrphanAll_Call) Return(err error) *MockStore_TransMapsOrphanAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsOrphanAll_Call) RunAndReturn(run func(ctx context.Context, mappingID string) error) *MockStore_TransMapsOrphanAll_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsOrphanCategories provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsOrphanCategories(ctx context.Context, mappingID string) error {
	ret := _mock.Called(ctx, mappingID)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsOrphanCategories")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, mappingID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsOrphanCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsOrphanCategories'
type MockStore_TransMapsOrphanCategories_Call struct {
	*mock.Call
}

// TransMapsOrphanCategories is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
func (_e *MockStore_Expecter) TransMapsOrphanCategories(ctx interface{}, mappingID interface{}) *MockStore_TransMapsOrphanCategories_Call {
	return &MockStore_TransMapsOrphanCategories_Call{Call: _e.mock.On("TransMapsOrphanCategories", ctx, mappingID)}
}

func (_c *MockStore_TransMapsOrphanCategories_Call) Run(run func(ctx context.Context, mappingID string)) *MockStore_TransMapsOrphanCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsOrphanCategories_Call) Return(err error) *MockStore_TransMapsOrphanCategories_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsOrphanCategories_Call) RunAndReturn(run func(ctx context.Context, mappingID string) error) *MockStore_TransMapsOrphanCategories_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsOrphanNames provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsOrphanNames(ctx context.Context, mappingID string) error {
	ret := _mock.Called(ctx, mappingID)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsOrphanNames")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, mappingID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsOrphanNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsOrphanNames'
type MockStore_TransMapsOrphanNames_Call struct {
	*mock.Call
}

// TransMapsOrphanNames is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
func (_e *MockStore_Expecter) TransMapsOrphanNames(ctx interface{}, mappingID interface{}) *MockStore_TransMapsOrphanNames_Call {
	return &MockStore_TransMapsOrphanNames_Call{Call: _e.mock.On("TransMapsOrphanNames", ctx, mappingID)}
}

func (_c *MockStore_TransMapsOrphanNames_Call) Run(run func(ctx context.Context, mappingID string)) *MockStore_TransMapsOrphanNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsOrphanNames_Call) Return(err error) *MockStore_TransMapsOrphanNames_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsOrphanNames_Call) RunAndReturn(run func(ctx context.Context, mappingID string) error) *MockStore_TransMapsOrphanNames_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsUpdateLinkedCategories provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsUpdateLinkedCategories(ctx context.Context, mappingID string, resolvedCategory *string) error {
	ret := _mock.Called(ctx, mappingID, resolvedCategory)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsUpdateLinkedCategories")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *string) error); ok {
		r0 = returnFunc(ctx, mappingID, resolvedCategory)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsUpdateLinkedCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsUpdateLinkedCategories'
type MockStore_TransMapsUpdateLinkedCategories_Call struct {
	*mock.Call
}

// TransMapsUpdateLinkedCategories is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
//   - resolvedCategory *string
func (_e *MockStore_Expecter) TransMapsUpdateLinkedCategories(ctx interface{}, mappingID interface{}, resolvedCategory interface{}) *MockStore_TransMapsUpdateLinkedCategories_Call {
	return &MockStore_TransMapsUpdateLinkedCategories_Call{Call: _e.mock.On("TransMapsUpdateLinkedCategories", ctx, mappingID, resolvedCategory)}
}

func (_c *MockStore_TransMapsUpdateLinkedCategories_Call) Run(run func(ctx context.Context, mappingID string, resolvedCategory *string)) *MockStore_TransMapsUpdateLinkedCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsUpdateLinkedCategories_Call) Return(err error) *MockStore_TransMapsUpdateLinkedCategories_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsUpdateLinkedCategories_Call) RunAndReturn(run func(ctx context.Context, mappingID string, resolvedCategory *string) error) *MockStore_TransMapsUpdateLinkedCategories_Call {
	_c.Call.Return(run)
	return _c
}

// TransMapsUpdateLinkedNames provides a mock function for the type MockStore
func (_mock *MockStore) TransMapsUpdateLinkedNames(ctx context.Context, mappingID string, resolvedName *string) error {
	ret := _mock.Called(ctx, mappingID, resolvedName)

	if len(ret) == 0 {
		panic("no return value specified for TransMapsUpdateLinkedNames")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *string) error); ok {
		r0 = returnFunc(ctx, mappingID, resolvedName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TransMapsUpdateLinkedNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransMapsUpdateLinkedNames'
type MockStore_TransMapsUpdateLinkedNames_Call struct {
	*mock.Call
}

// TransMapsUpdateLinkedNames is a helper method to define mock.On call
//   - ctx context.Context
//   - mappingID string
//   - resolvedName *string
func (_e *MockStore_Expecter) TransMapsUpdateLinkedNames(ctx interface{}, mappingID interface{}, resolvedName interface{}) *MockStore_TransMapsUpdateLinkedNames_Call {
	return &MockStore_TransMapsUpdateLinkedNames_Call{Call: _e.mock.On("TransMapsUpdateLinkedNames", ctx, mappingID, resolvedName)}
}

func (_c *MockStore_TransMapsUpdateLinkedNames_Call) Run(run func(ctx context.Context, mappingID string, resolvedName *string)) *MockStore_TransMapsUpdateLinkedNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_TransMapsUpdateLinkedNames_Call) Return(err error) *MockStore_TransMapsUpdateLinkedNames_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TransMapsUpdateLinkedNames_Call) RunAndReturn(run func(ctx context.Context, mappingID string, resolvedName *string) error) *MockStore_TransMapsUpdateLinkedNames_Call {
	_c.Call.Return(run)
	return _c
}

// TxFunc provides a mock function for the type MockStore
func (_mock *MockStore) TxFunc(ctx context.Context, h func(s store.Store) error) error {
	ret := _mock.Called(ctx, h)

	if len(ret) == 0 {
		panic("no return value specified for TxFunc")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(s store.Store) error) error); ok {
		r0 = returnFunc(ctx, h)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TxFunc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxFunc'
type MockStore_TxFunc_Call struct {
	*mock.Call
}

// TxFunc is a helper method to define mock.On call
//   - ctx context.Context
//   - h func(s store.Store) error
func (_e *MockStore_Expecter) TxFunc(ctx interface{}, h interface{}) *MockStore_TxFunc_Call {
	return &MockStore_TxFunc_Call{Call: _e.mock.On("TxFunc", ctx, h)}
}

func (_c *MockStore_TxFunc_Call) Run(run func(ctx context.Context, h func(s store.Store) error)) *MockStore_TxFunc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(s store.Store) error
		if args[1] != nil {
			arg1 = args[1].(func(s store.Store) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_TxFunc_Call) Return(err error) *MockStore_TxFunc_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TxFunc_Call) RunAndReturn(run func(ctx context.Context, h func(s store.Store) error) error) *MockStore_TxFunc_Call {
	_c.Call.Return(run)
	return _c
}
