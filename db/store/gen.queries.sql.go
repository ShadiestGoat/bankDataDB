// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: DBStore.sql

package store

import (
	"context"
	"time"
)

const doesCategoryExist = `-- name: DoesCategoryExist :one
SELECT EXISTS(
    SELECT 1 FROM categories
    WHERE
        author_id = $1
            AND
        id = $2
)
`

func (q *DBStore) DoesCategoryExist(ctx context.Context, authorID string, iD string) (bool, error) {
	row := q.db.QueryRow(ctx, doesCategoryExist, authorID, iD)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesMappingExist = `-- name: DoesMappingExist :one
SELECT EXISTS(
    SELECT 1 FROM mappings
    WHERE
        author_id = $1
            AND
        id = $2
)
`

func (q *DBStore) DoesMappingExist(ctx context.Context, authorID string, iD string) (bool, error) {
	row := q.db.QueryRow(ctx, doesMappingExist, authorID, iD)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesTransactionExist = `-- name: DoesTransactionExist :one
SELECT EXISTS(
    SELECT 1 FROM transactions
    WHERE
        author_id = $1
            AND
        authed_at = $2 AND settled_at = $3
            AND
        description = $4 AND amount = $5
)
`

func (q *DBStore) DoesTransactionExist(ctx context.Context, authorID string, authedAt time.Time, settledAt time.Time, description string, amount float64) (bool, error) {
	row := q.db.QueryRow(ctx, doesTransactionExist,
		authorID,
		authedAt,
		settledAt,
		description,
		amount,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getTransCount = `-- name: GetTransCount :one
SELECT COUNT(*) FROM transactions WHERE author_id = $1
`

func (q *DBStore) GetTransCount(ctx context.Context, authorID string) (int64, error) {
	row := q.db.QueryRow(ctx, getTransCount, authorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserUpdatedAt = `-- name: GetUserUpdatedAt :one
SELECT updated_at FROM users WHERE id = $1
`

func (q *DBStore) GetUserUpdatedAt(ctx context.Context, id string) (time.Time, error) {
	row := q.db.QueryRow(ctx, getUserUpdatedAt, id)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const mappingDelete = `-- name: MappingDelete :exec
DELETE FROM mappings WHERE id = $1
`

func (q *DBStore) MappingDelete(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, mappingDelete, id)
	return err
}

const mappingReset = `-- name: MappingReset :exec
UPDATE mappings SET
    name = $2,
    priority = $3,
    trans_text = $4,
    trans_amount = $5,
    res_name = $6,
    res_category = $7
WHERE id = $1
`

type MappingResetParams struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Priority    int32    `json:"priority"`
	TransText   *string  `json:"transText"`
	TransAmount *float64 `json:"transAmount"`
	ResName     *string  `json:"resName"`
	ResCategory *string  `json:"resCategory"`
}

func (q *DBStore) MappingReset(ctx context.Context, arg *MappingResetParams) error {
	_, err := q.db.Exec(ctx, mappingReset,
		arg.ID,
		arg.Name,
		arg.Priority,
		arg.TransText,
		arg.TransAmount,
		arg.ResName,
		arg.ResCategory,
	)
	return err
}

const resetCategoryData = `-- name: ResetCategoryData :exec
UPDATE categories SET name = $2, color = $3, icon = $4 WHERE id = $1
`

func (q *DBStore) ResetCategoryData(ctx context.Context, iD string, name string, color string, icon string) error {
	_, err := q.db.Exec(ctx, resetCategoryData,
		iD,
		name,
		color,
		icon,
	)
	return err
}
